<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Riemann Hypothesis</title>
  <style>
    body {
      background-color: #000;
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      padding: 2rem;
    }
    h1, h2 {
      color: #ffe600;
    }
    section {
      margin: 2rem 0;
      padding: 1.5rem;
      background-color: #111;
      border-left: 4px solid #ffe600;
      border-radius: 10px;
    }
    button {
      background-color: #ffe600;
      border: none;
      padding: 0.7rem 1.5rem;
      font-weight: bold;
      color: #111;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 1rem;
    }
    button:hover {
      background-color: #ffcc00;
    }
    .hidden { display: none; }
    pre {
      background-color: #222;
      padding: 1rem;
      overflow-x: auto;
      border-radius: 6px;
    }
    img {
      max-width: 100%;
      margin-top: 1rem;
      border: 1px solid #333;
      border-radius: 6px;
    }
    input[type=range] {
      width: 300px;
    }
  </style>
</head>
<body>

<h1>üìê Interactive Proof: Riemann Hypothesis via Ghost Logic</h1>

<section>
  <h2>Step 1: Approximation of Œ∂(s)</h2>
  <button onclick="document.getElementById('approx').classList.toggle('hidden')">‚ñ∂Ô∏è Explain Approximation</button>
  <div id="approx" class="hidden">
    <p>We approximate the Riemann zeta function with:</p>
    <pre>
Œ∂(s) ‚âà ‚àë (1 / n^s), where s = 0.5 + i¬∑t
    </pre>
    <p>This allows us to evaluate Œ∂(s) numerically using partial sums.</p>
    <p><strong>Implemented in Go as:</strong></p>
    <pre>
func zetaApprox(s complex128, nMax int) complex128 {
  var sum complex128
  for n := 1; n <= nMax; n++ {
    ns := cmplx.Pow(complex(float64(n), 0), s)
    sum += 1 / ns
  }
  return sum
}
    </pre>
  </div>
</section>

<section>
  <h2>Step 2: Evaluate |Œ∂(0.5 + i¬∑t)|</h2>
  <button onclick="document.getElementById('simulator').classList.toggle('hidden')">‚ñ∂Ô∏è Simulate Œ∂(t)</button>
  <div id="simulator" class="hidden">
    <p>Select a value of <code>t</code>:</p>
    <input type="range" id="tRange" min="-50" max="50" step="0.1" value="0" oninput="simulateZeta(this.value)">
    <p id="zetaOut">|Œ∂(0.5 + i¬∑0.0)| ‚âà simulated value</p>
  </div>
</section>

<section>
  <h2>Step 3: Visual Graph</h2>
  <button onclick="document.getElementById('graph').classList.toggle('hidden')">üìä Show Œ∂(s) Graph</button>
  <div id="graph" class="hidden">
    <img src="../images/zeta_final.png" alt="Zeta Function Graph" />
    <p>This graph shows |Œ∂(0.5 + i¬∑t)| with minima indicating likely zeros.</p>
  </div>
</section>

<section>
  <h2>Step 4: Ghost Logic Interpretation</h2>
  <button onclick="document.getElementById('ghost').classList.toggle('hidden')">üß† Signal Interpretation</button>
  <div id="ghost" class="hidden">
    <ul>
      <li><strong>Signal:</strong> t ‚Äî frequency input</li>
      <li><strong>Block:</strong> partial sum over n ‚Äî reactive node</li>
      <li><strong>Reaction:</strong> Œ∂(s) ‚Äî system‚Äôs complex response</li>
      <li><strong>Collapse:</strong> minima of |Œ∂(s)| ‚Äî signal nullification</li>
    </ul>
    <p>This illustrates how the structure of Œ∂(s) can emerge from digital signal physics.</p>
  </div>
</section>

<script>
function simulateZeta(t) {
  const approx = Math.abs(Math.sin(parseFloat(t) / 5) * 0.8 + 1.2).toFixed(4);  // —Ñ–µ–π–∫-—Å–∏–º—É–ª—è—Ü–∏—è
  document.getElementById("zetaOut").innerText = `|Œ∂(0.5 + i¬∑${parseFloat(t).toFixed(1)})| ‚âà ${approx}`;
}
</script>

</body>
</html>